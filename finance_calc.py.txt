import streamlit as st
import numpy as np
from scipy.stats import norm

# --- 1. è¨­å®š & è¨€èªãƒ‡ãƒ¼ã‚¿ (Configuration & Localization) ---
st.set_page_config(
    page_title="Quant Calculator Pro",
    page_icon="ğŸ“ˆ",
    layout="centered"
)

# ç¿»è¨³è¾æ›¸
TRANS = {
    "JP": {
        "title": "é«˜åº¦é‡‘èè¨ˆç®—æ©Ÿ (Quant Calculator)",
        "sidebar_title": "è¨ˆç®—ãƒ¢ãƒ‡ãƒ«é¸æŠ",
        "lang_select": "è¨€èª / Language",
        "calc_bs": "ãƒ–ãƒ©ãƒƒã‚¯ãƒ»ã‚·ãƒ§ãƒ¼ãƒ«ã‚º (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)",
        "calc_kelly": "ã‚±ãƒªãƒ¼åŸºæº– (è³‡é‡‘ç®¡ç†)",
        "calc_var": "VaR (ãƒãƒªãƒ¥ãƒ¼ãƒ»ã‚¢ãƒƒãƒˆãƒ»ãƒªã‚¹ã‚¯)",
        "calc_btn": "è¨ˆç®—ã™ã‚‹",
        "result": "è¨ˆç®—çµæœ",
        "desc_bs": "ã‚³ãƒ¼ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ç†è«–ä¾¡æ ¼ã¨ã‚°ãƒªãƒ¼ã‚¯ã‚¹ã‚’è¨ˆç®—ã—ã¾ã™ã€‚",
        "desc_kelly": "ç ´ç”£ã‚’é¿ã‘ã¤ã¤è³‡ç”£ã‚’æœ€å¤§åŒ–ã™ã‚‹æœ€é©ãªæŠ•è³‡æ¯”ç‡ã‚’è¨ˆç®—ã—ã¾ã™ã€‚",
        "desc_var": "ç‰¹å®šã®ç¢ºç‡ã§ç™ºç”Ÿã—ã†ã‚‹æœ€å¤§æå¤±é¡ã‚’è¨ˆç®—ã—ã¾ã™ã€‚",
        # Black-Scholes Inputs
        "bs_s": "ç¾åœ¨æ ªä¾¡ (S)",
        "bs_k": "è¡Œä½¿ä¾¡æ ¼ (K)",
        "bs_t": "æº€æœŸã¾ã§ã®æœŸé–“ (å¹´)",
        "bs_r": "ç„¡ãƒªã‚¹ã‚¯é‡‘åˆ© (%)",
        "bs_v": "ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ (%)",
        "bs_call": "ã‚³ãƒ¼ãƒ«ä¾¡æ ¼",
        # Kelly Inputs
        "kelly_p": "å‹ç‡ (%)",
        "kelly_rr": "ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚·ã‚ª (åˆ©ç›Š/æå¤±)",
        "kelly_res": "æ¨å¥¨ãƒ¬ãƒãƒ¬ãƒƒã‚¸ (è³‡é‡‘ã®%)",
        "kelly_note": "â€»å®Ÿå‹™ã§ã¯è¨ˆç®—çµæœã®åŠåˆ†(ãƒãƒ¼ãƒ•ã‚±ãƒªãƒ¼)ã‚’ä½¿ã†ã“ã¨ãŒä¸€èˆ¬çš„ã§ã™ã€‚",
        # VaR Inputs
        "var_amt": "æŠ•è³‡å…ƒæœ¬",
        "var_vol": "å¹´ç‡ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ (%)",
        "var_conf": "ä¿¡é ¼åŒºé–“ (%)",
        "var_day": "ä¿æœ‰æœŸé–“ (æ—¥)",
        "var_res": "æ¨å®šæœ€å¤§æå¤±é¡",
        # Disclaimer
        "disclaimer": "å…è²¬äº‹é …: æœ¬ãƒ„ãƒ¼ãƒ«ã®è¨ˆç®—çµæœã¯å‚è€ƒå€¤ã§ã‚ã‚Šã€æŠ•è³‡å‹§èª˜ã‚„åˆ©ç›Šã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§è¡Œã£ã¦ãã ã•ã„ã€‚"
    },
    "EN": {
        "title": "Quant Calculator Pro",
        "sidebar_title": "Select Model",
        "lang_select": "Language",
        "calc_bs": "Black-Scholes (Option Pricing)",
        "calc_kelly": "Kelly Criterion (Money Mgmt)",
        "calc_var": "Value at Risk (VaR)",
        "calc_btn": "Calculate",
        "result": "Result",
        "desc_bs": "Calculate theoretical call option price and Greeks.",
        "desc_kelly": "Calculate optimal bet size to maximize wealth while avoiding ruin.",
        "desc_var": "Estimate the maximum potential loss with a given confidence level.",
        # Black-Scholes Inputs
        "bs_s": "Spot Price (S)",
        "bs_k": "Strike Price (K)",
        "bs_t": "Time to Maturity (Years)",
        "bs_r": "Risk-Free Rate (%)",
        "bs_v": "Volatility (%)",
        "bs_call": "Call Price",
        # Kelly Inputs
        "kelly_p": "Win Rate (%)",
        "kelly_rr": "Risk/Reward Ratio",
        "kelly_res": "Optimal Leverage (% of Equity)",
        "kelly_note": "*It is common practice to use half of this value (Half-Kelly).",
        # VaR Inputs
        "var_amt": "Portfolio Value",
        "var_vol": "Annual Volatility (%)",
        "var_conf": "Confidence Level (%)",
        "var_day": "Holding Period (Days)",
        "var_res": "Estimated Max Loss (VaR)",
        # Disclaimer
        "disclaimer": "Disclaimer: Results are for informational purposes only. Trading involves risk."
    }
}

# --- 2. è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ (Calculation Logic) ---

def black_scholes(S, K, T, r, sigma):
    # r and sigma should be in decimal (e.g., 0.05 for 5%)
    if T <= 0 or sigma <= 0:
        return 0.0
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    call_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return call_price

def kelly_criterion(win_rate, risk_reward):
    # win_rate in decimal
    # f = p - q / b  where p=win, q=loss, b=odds(risk_reward)
    p = win_rate
    q = 1 - p
    b = risk_reward
    if b == 0: return 0.0
    f = (p * (b + 1) - 1) / b
    return f * 100 # return as percentage

def calculate_var(amount, volatility_annual, confidence, days):
    # Convert annual vol to period vol
    vol_period = (volatility_annual) * np.sqrt(days / 252)
    z_score = norm.ppf(confidence)
    var = amount * vol_period * z_score
    return var

# --- 3. UIæ§‹ç¯‰ (User Interface) ---

def main():
    # ã‚µã‚¤ãƒ‰ãƒãƒ¼ã§è¨€èªé¸æŠ
    lang_opt = st.sidebar.radio("Language / è¨€èª", ["æ—¥æœ¬èª", "English"])
    lang = "JP" if lang_opt == "æ—¥æœ¬èª" else "EN"
    txt = TRANS[lang]

    st.title(txt["title"])

    # ã‚µã‚¤ãƒ‰ãƒãƒ¼ã§æ©Ÿèƒ½é¸æŠ
    menu = [txt["calc_bs"], txt["calc_kelly"], txt["calc_var"]]
    choice = st.sidebar.selectbox(txt["sidebar_title"], menu)

    st.markdown("---")

    # === VIEW: Black Scholes ===
    if choice == txt["calc_bs"]:
        st.subheader(txt["calc_bs"])
        st.info(txt["desc_bs"])
        
        col1, col2 = st.columns(2)
        s = col1.number_input(txt["bs_s"], value=100.0)
        k = col2.number_input(txt["bs_k"], value=100.0)
        t = col1.number_input(txt["bs_t"], value=1.0)
        r = col2.number_input(txt["bs_r"], value=5.0)
        v = col1.number_input(txt["bs_v"], value=20.0)

        if st.button(txt["calc_btn"], key="btn_bs"):
            price = black_scholes(s, k, t, r/100, v/100)
            st.success(f"**{txt['bs_call']}: {price:.2f}**")
            
            # ç°¡æ˜“ã‚¢ãƒ•ã‚£ãƒªã‚¨ã‚¤ãƒˆã‚¨ãƒªã‚¢ (ä¾‹)
            st.markdown("---")
            if lang == "JP":
                st.markdown("ğŸ’¡ **ã‚ªãƒ—ã‚·ãƒ§ãƒ³å–å¼•ã‚’å­¦ã¶ãªã‚‰**: [ãŠã™ã™ã‚ã®è¨¼åˆ¸å£åº§ãƒªãƒ³ã‚¯(A8ãªã©)] | [å°‚é–€æ›¸ç±ãƒªãƒ³ã‚¯]")
            else:
                st.markdown("ğŸ’¡ **Learn Options Trading**: [Affiliate Link]")

    # === VIEW: Kelly Criterion ===
    elif choice == txt["calc_kelly"]:
        st.subheader(txt["calc_kelly"])
        st.info(txt["desc_kelly"])

        col1, col2 = st.columns(2)
        p = col1.number_input(txt["kelly_p"], value=50.0, max_value=100.0)
        rr = col2.number_input(txt["kelly_rr"], value=1.5)

        if st.button(txt["calc_btn"], key="btn_kelly"):
            f = kelly_criterion(p/100, rr)
            
            st.metric(label=txt["kelly_res"], value=f"{f:.2f} %")
            
            if f > 0:
                st.write(f"Half Kelly: {f/2:.2f} %")
            else:
                st.error("Don't trade (Expected Value is negative).")
            
            st.caption(txt["kelly_note"])

            # ç°¡æ˜“ã‚¢ãƒ•ã‚£ãƒªã‚¨ã‚¤ãƒˆã‚¨ãƒªã‚¢
            st.markdown("---")
            if lang == "JP":
                st.markdown("ğŸ“š **è³‡é‡‘ç®¡ç†ã®åè‘—**: [æŠ•è³‡è‹‘(Amazonãƒªãƒ³ã‚¯)] | [ãƒãƒ¼ã‚±ãƒƒãƒˆã®é­”è¡“å¸«(Amazonãƒªãƒ³ã‚¯)]")

    # === VIEW: VaR ===
    elif choice == txt["calc_var"]:
        st.subheader(txt["calc_var"])
        st.info(txt["desc_var"])

        amt = st.number_input(txt["var_amt"], value=1000000)
        col1, col2 = st.columns(2)
        vol = col1.number_input(txt["var_vol"], value=20.0)
        conf = col2.selectbox(txt["var_conf"], [99.0, 95.0, 90.0])
        days = st.slider(txt["var_day"], 1, 365, 10)

        if st.button(txt["calc_btn"], key="btn_var"):
            res = calculate_var(amt, vol/100, conf/100, days)
            st.error(f"**{txt['var_res']}: -{res:,.0f}**")

    st.markdown("<a href="https://px.a8.net/svt/ejp?a8mat=4AV8S7+B2WG36+ONS+TT69D" rel="nofollow">
<img border="0" width="320" height="50" alt="" src="https://www22.a8.net/svt/bgt?aid=260118583670&wid=001&eno=01&mid=s00000003196005007000&mc=1"></a>
<img border="0" width="1" height="1" src="https://www16.a8.net/0.gif?a8mat=4AV8S7+B2WG36+ONS+TT69D" alt="">")
    st.caption(txt["disclaimer"])

if __name__ == "__main__":
    main()